;;ToDo : 最終的には uml-interface.stencil に集約するか．．．

(in-package :cl-diagram-user)

(load-stencil :uml-interface)

(defparameter *uml-interface-request-stroke*         :black)
(defparameter *uml-interface-request-degree*            150)
(defparameter *uml-interface-request-length-threshold*   40)
(defparameter *uml-interface-request-maximum-dependency* 40)

(defun calculate-degrees (cx cy points degree)
  (labels ((reverse-degree (sin cos)
			 (when (< 1 (abs cos))
			   (setf cos (round cos)))
			 (let* ((RADIAN-UNIT (/ pi 180))
					(acos        (/ (cl:acos cos) RADIAN-UNIT)))
			   (round (if (<= 0 sin)
						  acos
						  (- 360 acos))))))
	(multiple-value-bind (px py)
		(do ((pts1 points (cdr pts1))
			 (pts2 (cddr points) (cdr pts2)))
			((null pts2) (values (car pts1) (cadr pts1))))
	  (let ((half (/ degree 2)))
		(values (reverse-degree (math/sin5 cx cy px py (- 360 half))
								(math/cos5 cx cy px py (- 360 half)))
				(reverse-degree (math/sin5 cx cy px py half)
								(math/cos5 cx cy px py half)))))))



;; (0 1 2 3 4 5 6 7) ->  tail (6 7) & copied (4 5 6 7).
(defun get-last-2-points (points &optional (cnt nil))
  (if (null cnt)
	  (let ((cnt (length points)))
		(unless (and (<= 4 cnt) (zerop (mod cnt 2)))
		  (error "Invalid points list."))
		(get-last-2-points points cnt))
	  (if (= cnt 4)
		  (values (cddr points) (copy-list points))
		  (get-last-2-points (cdr points) (1- cnt)))))

;;returns 4 values
(defun fix-points (arrow-p radius points)
  (multiple-value-bind (tail last2) (get-last-2-points points)
	(let ((x   (first  tail))
		  (y   (second tail))
		  (sin (apply #'math/sin4 last2))
		  (cos (apply #'math/cos4 last2))
		  (len (apply #'math/len4 last2)))
	  (if (or (not arrow-p)
			  (< len *uml-interface-request-length-threshold*))
		  (progn
			(decf (first  tail) (* radius cos))
			(decf (second tail) (* radius sin))
			(setf last2 nil))
		  (let ((half (/ len 2)))
			(when (< *uml-interface-request-maximum-dependency* half)
			  (setf half (- len *uml-interface-request-maximum-dependency*)))
			(setf x (+ (first  last2) (* half cos)))
			(setf y (+ (second last2) (* half sin)))
			(setf (first  tail)  (- x (* radius cos)))
			(setf (second tail)  (- y (* radius sin)))
			(setf (first  last2) (- x (* radius cos)))
			(setf (second last2) (- y (* radius sin)))))
	  (values points last2 x y))))



;-------------------------------------------------------------------------------
;
; class uml-interface-request
;
;-------------------------------------------------------------------------------
(defclass uml-interface-request (diagram:connector)
  ((arrow-p			;:type     boolean value
					:initform nil
					:initarg  :arrow-p
					:accessor uml-interface-request-arrow-p)
   (canvas-cache	;:type     (or nil canvas)
					:initform nil)
   (x-cache			;:type     number
					:initform 0)
   (y-cache			;:type     (or nil uml-role-info)
					:initform 0)
   (points-cache	;:type     list
					:initform nil)
   (radius-cache	;:type     number
					:initform *uml-interface-radius*)
   (degree-cache	;:type     number
					:initform *uml-interface-request-degree*)))

;;no implementation...
;;(defmethod initialize-instance :after ((req uml-interface-request) &rest initargs)
;;  (declare (ignore initargs))
;;  req)


(defmethod check ((req uml-interface-request) canvas dict)
  ;; this method must call super class' one.
  (call-next-method)
  (with-slots (arrow-p x-cache y-cache
				canvas-cache points-cache radius-cache) req
	(setf canvas-cache (copy-canvas canvas))
	(let ((new-points nil))
	  (multiple-value-setq (new-points points-cache x-cache y-cache)
								(fix-points arrow-p radius-cache
											(copy-list (diagram::line-points req))))
	  (let ((left (canvas-left canvas))
			(top  (canvas-top  canvas)))
		(decf x-cache left)
		(decf y-cache  top)
		(when points-cache
		  (decf (first  points-cache) left)
		  (decf (second points-cache)  top)
		  (decf (third  points-cache) left)
		  (decf (fourth points-cache)  top)))
	  (setf (diagram::line-points req) new-points)))
  nil)

(defmethod entity-composition-p ((req uml-interface-request))
  (declare (ignore req))
  t)

(defmethod post-draw ((req uml-interface-request) writer)
  (with-slots (canvas-cache points-cache x-cache y-cache
				degree-cache radius-cache diagram::stroke) req
	(let ((canvas canvas-cache))
	  (declare (special canvas))
	  (macrolet ((register-entity (entity)
				   `(check-and-draw-local-entity ,entity canvas writer)))
		(let ((*default-stroke* diagram::stroke))
		  (when points-cache
			(line points-cache :end1 nil :end2 :arrow
							   :stroke '(:dasharray (3 3)))) ; ToDo : fix ?
			  (multiple-value-bind (deg1 deg2)
				  (calculate-degrees (+ x-cache (canvas-left canvas))
									 (+ y-cache (canvas-top  canvas))
									 (copy-list (diagram::line-points req)) degree-cache)
				(when (<= 360 deg1) (decf deg1 360))
				(when (<= 360 deg2) (decf deg2 360))
				(arc x-cache y-cache radius-cache deg1 deg2))))))
  (call-next-method))


(defmacro uml-interface-request (from to &key arrow-p style stroke layer id)
  `(register-entity (make-instance 'uml-interface-request
								   :from ,from :to ,to
								   :arrow-p ,arrow-p :style ,style
								   :stroke (or ,stroke
											   *uml-interface-request-stroke*
											   *default-stroke* :black)
								   :end1 nil :end2 nil :layer ,layer :id ,id)))
